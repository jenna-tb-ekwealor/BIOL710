---
title: "Probability"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
---

```{r setup, include=FALSE,message=FALSE}
library(BIOL710AdvBiometry)
library(learnr)
library(sf)               # working with vector data
library(afrilearndata)    # example data
library(tmap)             # static and interactive mapping
library(raster)           # raster manipulation

library(learnrhash)
library(tidyverse)
library(gradethis)
library(openintro)
library(infer)
tutorial_options(
  # use gradethis for checking
  exercise.checker = gradethis::grade_learnr
  )
knitr::opts_chunk$set(echo = FALSE)

coin_outcomes <- c("heads", "tails")
shot_outcomes <- c("H", "M")

```

## Getting Started

### Load packages

In this lab, we will explore and visualize the data using the `tidyverse` suite of 
packages. The data can be found in the companion package for OpenIntro labs, **openintro**.

Let's load the packages.

```{r load-packages, exercise = T}
library(tidyverse)
library(openintro)
```


### Data

Basketball players who make several baskets in succession are described as 
having a *hot hand*. Fans and players have long believed in the hot hand 
phenomenon, which refutes the assumption that each shot is independent of the 
next. However, [a 1985 paper](http://www.sciencedirect.com/science/article/pii/0010028585900106) by Gilovich, Vallone, and Tversky collected evidence
that contradicted this belief and showed that successive shots are independent 
events. This paper started a great controversy that continues to this day, as you can 
see by Googling *hot hand basketball*.

More examples:

- [Golden State Warriors and the Hot Hand](https://link.springer.com/content/pdf/10.1007/s00283-018-9825-3.pdf)

- [Hot Hand in Baseball](http://cdar.berkeley.edu/wp-content/uploads/2020/03/Hot-or-Not.pdf)

We do not expect to resolve this controversy today. However, in this lab we'll 
apply one approach to answering questions like this. The goals for this lab are 
to (1) think about the effects of independent and dependent events, (2) learn 
how to simulate shooting streaks in R, and (3) to compare a simulation to actual
data in order to determine if the hot hand phenomenon appears to be real.


CW: death, plane crash

Your investigation will focus on the performance of one player: [Kobe Bryant](https://en.wikipedia.org/wiki/Kobe_Bryant) formally of the Los Angeles Lakers before his tragic death in a plane crash. His performance against the Orlando Magic in the [2009 NBA Finals](https://en.wikipedia.org/wiki/2009_NBA_Finals) earned him the title *Most Valuable Player* and many spectators commented on how he appeared to show a hot hand. The data file we'll use is called `kobe_basket`.

```{r glimpse-data, exercise = T}
glimpse(kobe_basket)
```

This data frame contains 133 observations and 6 variables, where every
row records a shot taken by Kobe Bryant. The `shot` variable in this dataset
indicates whether the shot was a hit (`H`) or a miss (`M`).

## Looking for streaks

Just looking at the string of hits and misses, it can be difficult to gauge 
whether or not it seems like Kobe was shooting with a hot hand. One way we can 
approach this is by considering the belief that hot hand shooters tend to go on 
shooting streaks. For this lab, we define the length of a shooting streak to be 
the *number of consecutive baskets made until a miss occurs*.

For example, in Game 1 Kobe had the following sequence of hits and misses from 
his nine shot attempts in the first quarter:

\[ \textrm{H M | M | H H M | M | M | M} \]

You can verify this by viewing the first 9 rows of the data in the data viewer.

Within the nine shot attempts, there are six streaks, which are separated by a 
"|" above. Their lengths are one, zero, two, zero, zero, zero (in order of 
occurrence).

Counting streak lengths manually for all 133 shots would get tedious, so we'll
use the custom function `calc_streak` to calculate them, and store the results
in a data frame called `kobe_streak` as the `length` variable.

```{r calc-streak-kobe, exercise = T}
kobe_streak <- calc_streak(kobe_basket$shot)

head(kobe_streak)
```

We can then take a look at the distribution of these streak lengths.

```{r plot-streak-kobe-setup}
kobe_streak <- calc_streak(kobe_basket$shot)

```

```{r plot-streak-kobe, exercise = TRUE}
ggplot(data = kobe_streak, aes(x = length)) +
  geom_bar() + ylim(0,50) + xlim(-1,7) 
## these xlim and ylims help us keep the scales the same to make comparison between bar plots easier
```

```{r maxstreak}
question("What was Kobe's typical streak length (or mode)?",
    answer("0", correct = T),
    answer("1"),
    answer("2"),
    answer("3"),
    answer("4"),
    allow_retry = TRUE,
    random_answer_order = F
  )
```

```{r typicalstreak}
question("How long was his longest streak of baskets (or maximum)?",
  answer("0"),
    answer("1"),
    answer("2"),
    answer("3"),
    answer("4", correct = T),
    allow_retry = TRUE,
    random_answer_order = F
  )
```



## [Compared to what?](https://youtu.be/VF9-sEbqDvU?t=162)

We've shown that Kobe had some long shooting streaks, but are they long enough 
to support the belief that he had a hot hand? What can we compare them to?

To answer these questions, let's return to the idea of *independence*. Two 
processes are independent if the outcome of one process doesn't effect the outcome 
of the second. If each shot that a player takes is an independent process, 
having made or missed your first shot will not affect the probability that you
will make or miss your second shot.

A shooter with a hot hand will have shots that are *not* independent of one 
another. Specifically, if the shooter makes his first shot, the hot hand model 
says he will have a *higher* probability of making his second shot.

Let's suppose for a moment that the hot hand model is valid for Kobe. During his
career, the percentage of time Kobe makes a basket (i.e. his shooting 
percentage) is about 45%, or in probability notation,

\[ P(\textrm{shot 1 = H}) = 0.45 \]

If he makes the first shot and has a hot hand (*not* independent shots), then 
the probability that he makes his second shot would go up to, let's say, 60%,

\[ P(\textrm{shot 2 = H} \, | \, \textrm{shot 1 = H}) = 0.60 \]

As a result of these increased probabilites, you'd expect Kobe to have longer 
streaks. Compare this to the skeptical perspective where Kobe does *not* have a
hot hand, where each shot is independent of the next. If he hit his first shot,
the probability that he makes the second is still 0.45.

\[ P(\textrm{shot 2 = H} \, | \, \textrm{shot 1 = H}) = 0.45 \]

In other words, making the first shot did nothing to effect the probability that
he'd make his second shot. If Kobe's shots are independent, then he'd have the 
same probability of hitting every shot regardless of his past shots: 45%.

Now that we've phrased the situation in terms of independent shots, let's return
to the question: how do we tell if Kobe's shooting streaks are long enough to 
indicate that he has a hot hand? We can compare his streak lengths to someone
without a hot hand: an independent shooter. 

## Simulations in R

While we don't have any data from a shooter we know to have independent shots, 
that sort of data is very easy to simulate in R. In a simulation, you set the 
ground rules of a random process and then the computer uses random numbers to 
generate an outcome that adheres to those rules. As a simple example, you can
simulate flipping a fair coin with the following.

```{r head-tail, exercise = T}
coin_outcomes <- c("heads", "tails")
sample(coin_outcomes, size = 1, replace = TRUE)
```

The vector `coin_outcomes` can be thought of as a hat with two slips of paper in it: 
one slip says `heads` and the other says `tails`. The function `sample` draws 
one slip from the hat and tells us if it was a head or a tail. Note `sample` (with argument `size`) works on a vector while `slice_sample` (with argument `n`) works on a data frame.

Run the second command listed above several times. Just like when flipping a 
coin, sometimes you'll get a heads, sometimes you'll get a tails, but *in the 
long run*, you'd expect to get roughly equal numbers of each.

If you wanted to simulate flipping a fair coin 100 times, you could either run 
the function 100 times or, more simply, adjust the `size` argument, which 
governs how many samples to draw (the `replace = TRUE` argument indicates we put
the slip of paper back in the hat before drawing again). Save the resulting 
vector of heads and tails in a new object called `sim_fair_coin`.

```{r sim-fair-coin, exercise = T}
sim_fair_coin <- sample(coin_outcomes, size = 100, replace = TRUE)
```

To view the results of this simulation, type the name of the object and then use
`table` to count up the number of heads and tails.

```{r table-sim-fair-coin-setup}
sim_fair_coin <- sample(coin_outcomes, size = 100, replace = TRUE)
```

```{r table-sim-fair-coin, exercise = TRUE}
sim_fair_coin
table(sim_fair_coin)
```

Since there are only two elements in `coin_outcomes`, the probability that we "flip" 
a coin and it lands heads is 0.5. Say we're trying to simulate an unfair coin 
that we know only lands heads 20% of the time. We can adjust for this by adding 
an argument called `prob`, which provides a vector of two probability weights.

```{r sim-unfair-coin, exercise = T}
sim_unfair_coin <- sample(coin_outcomes, size = 100, replace = TRUE, 
                          prob = c(0.2, 0.8))
```

`prob=c(0.2, 0.8)` indicates that for the two elements in the `outcomes` vector,
we want to select the first one, `heads`, with probability 0.2 and the second 
one, `tails` with probability 0.8. In previous examples we have actually genreated the outcome space and sampled directly from it rather than specifying probabilities (like we have a bag of 10 chips, where 2 chips are labeled 
"head" and 8 chips "tail"). In either approach, at each draw, the probability of drawing a 
chip that says "head"" is 20%, and "tail" is 80%.

Another way to think about it is that we've shrunken the size of the slip of paper that says "heads", 
making it less likely to be drawn, and we've increased the size of the slip of 
paper saying "tails", making it more likely to be drawn. When you simulated the 
fair coin, both slips of paper were the same size. This happens by default if 
you don't provide a `prob` argument; all elements in the `outcomes` vector have 
an equal probability of being drawn.

If you want to learn more about `sample` or any other function, recall that you 
can always check out its help file.

In your simulation of flipping the unfair coin 100 times, how many flips 
    came up heads?
    
```{r umttjrtwhfgnldyz-setup}
set.seed(129149)
sim_unfair_coin <- sample(coin_outcomes, size = 100, replace = TRUE, 
                          prob = c(0.2, 0.8))
```

```{r umttjrtwhfgnldyz, exercise = TRUE}
table(___)
```

```{r umttjrtwhfgnldyz-solution}
table(sim_unfair_coin)
```

```{r umttjrtwhfgnldyz-check}
# check code
gradethis::grade_code()
```
    

## Simulating the Independent Shooter

Simulating a basketball player who has independent shots uses the same mechanism 
that you used to simulate a coin flip. To simulate a single shot from an 
independent shooter with a shooting percentage of 50% you can type

```{r sim-basket, exercise = T}
shot_outcomes <- c("H", "M")
sim_basket <- sample(shot_outcomes, size = 1, replace = TRUE)
```

To make a valid comparison between Kobe and your simulated independent shooter, 
you need to align both their shooting percentage and the number of attempted shots.


How can we sample 133 shots reflecting a shooting percentage of 45%? 

```{r ihnlvvbzmksklpev, exercise = TRUE}
sim_basket <- sample(shot_outcomes, size = ___, prob = c(___, ___), replace = TRUE)
```

```{r ihnlvvbzmksklpev-solution}
sim_basket <- sample(shot_outcomes, size = 133, prob = c(0.45, 0.55), replace = TRUE)
```

```{r ihnlvvbzmksklpev-check}
# check code
gradethis::grade_code()
```


Note that we've named the new vector `sim_basket`, the same name that we gave to
the previous vector reflecting a shooting percentage of 50%. In this situation, 
R overwrites the old object with the new one, so always make sure that you don't
need the information in an old vector before reassigning its name.

With the results of the simulation saved as `sim_basket`, you have the data 
necessary to compare Kobe to our independent shooter.

Both data sets represent the results of 133 shot attempts, each with the same 
shooting percentage of 45%. We know that our simulated data is from a shooter 
that has independent shots. That is, we know the simulated shooter does not have
a hot hand.

## Comparing Kobe Bryant to the Independent Shooter

Compute the streak lengths of `sim_basket`, and save the results in a data frame called `sim_streak`.

```{r dntpctxmrejxvcuo-setup}
set.seed(129154)
sim_basket <- sample(shot_outcomes, size = 133, prob = c(0.45, 0.55), replace = TRUE)
```

```{r dntpctxmrejxvcuo, exercise = TRUE}
___ <- ___(sim_basket)

```


```{r dntpctxmrejxvcuo-solution}
# solution code
sim_streak <- calc_streak(sim_basket)

```

```{r dntpctxmrejxvcuo-check}
# check code
gradethis::grade_code()
```

Make a bar plot of the streaks.

```{r gpsurtgdpohztbuk-setup}
set.seed(129154)
sim_basket <- sample(shot_outcomes, size = 133, prob = c(0.45, 0.55), replace = TRUE)
sim_streak <- calc_streak(sim_basket)

```

```{r gpsurtgdpohztbuk, exercise = TRUE}
ggplot(data = ___, aes(x = ___)) +
  ___
```

```{r gpsurtgdpohztbuk-hint-1}
ggplot(data = ___, aes(x = ___)) +
  geom_bar() 
```

```{r gpsurtgdpohztbuk-solution}
ggplot(data = sim_streak, aes(x = length)) +
  geom_bar() 
```


```{r gpsurtgdpohztbuk-check}
# check code
gradethis::grade_code()
```


```{r maxstreak2}
question("What is the typical streak length for this simulated independent shooter with a 45% shooting percentage?",
    answer("0", correct = T),
    answer("1"),
    answer("2"),
    answer("3"),
    answer("4"),
    allow_retry = TRUE,
    random_answer_order = F
  )
```

```{r typicalstreak2}
question("How long is the player's longest streak of baskets in 133 shots?",
  answer("0"),
    answer("1"),
    answer("2"),
    answer("3"),
    answer("4", correct = T),
    allow_retry = TRUE,
    random_answer_order = F
  )
```

## Did Kobe have a hot hand?

```{r compare-plots-setup}
set.seed(129154)
sim_basket <- sample(shot_outcomes, size = 133, prob = c(0.45, 0.55), replace = TRUE)
sim_streak <- calc_streak(sim_basket)

kobe_streak <- calc_streak(kobe_basket$shot)

```

```{r compare-plots, exercise = TRUE}
ggplot(data = kobe_streak, aes(x = length)) +
  geom_bar() + ylim(0,50) + xlim(-1,7) 

ggplot(data = sim_streak, aes(x = length)) +
  geom_bar() + ylim(0,50) + xlim(-1,7) 
```

```{r kobecompare}
question("How does Kobe Bryant's distribution of streak lengths compare to the distribution of streak lengths for the simulated shooter? ",
    answer("The distributions look roughly the same.", correct = T),
    answer("Kobe's distribution is more right skewed."),
    answer("Kobe's distribution is more left skewed."),
    allow_retry = TRUE,
    random_answer_order = F
  )
```

```{r kobecompare2}
question("Do you have evidence that the hot hand model fits Kobe's 
    shooting patterns?",
    answer("Yes, a hot hand is associated with longer streaks which Kobe has."),
    answer("Yes, a hot hand is associated with shorter streaks which Kobe has."),
    answer("No, a hot hand is associated with longer streaks which Kobe does not have.", correct = T),
    allow_retry = TRUE,
    random_answer_order = F
  )
```

    
## Submit checkpoint

```{r context="server"}
learnrhash::encoder_logic(strip_output = T)
```

```{r encode, echo=FALSE}
learnrhash::encoder_ui(
  ui_before = div(strong("Submit your hash in the form below."), br(), br()),
  ui_after  = learnrhash::iframe_ui(
    src = "https://docs.google.com/forms/d/e/1FAIpQLSfKAR9MMxfAR8EWsCi-U2Ow4SjsejLlAUba14FBsch-gox0Gg/viewform?usp=sf_link",
    width="900px", height= "1000px"
  )
)
```

# default options for all chunks
knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE )

library(sf)               # working with vector data
library(afrilearndata)    # example data
library(tmap)             # static and interactive mapping
library(raster)           # raster manipulation
#library(rgdal)           # raster tiff reading
#library(dplyr)           # data wrangling
#library(mapview)         # interactive mapping

# to make local running the same as linux on shinyapps
# see https://github.com/rstudio/learnr/issues/529
#options(tutorial.exercise.evaluator = learnr:::forked_evaluator)
# 2021-05-26 but gave me local error : Warning: Error in : 'mcparallel' is not an exported object from 'namespace:parallel'

```


## A. Outline of this tutorial

This is an entry level introduction to spatial data in R using examples from Africa. It is aimed at those with a little knowledge of R.


### Outline of afrilearnr

This pre-lab is borrowed from the [afrilearnr](https://github.com/afrimapr/afrilearnr) package containing tutorials to teach spatial data skills in R with African data. It is part of the [afrimapr](https://afrimapr.github.io/afrimapr.website/) project.


## B. Spatial data outline

We will start by looking at these spatial data for Africa, shown in the map below. 

1. Capital city locations (points)
1. A highway network (lines)
1. Country boundaries (polygons)
1. Population density (gridded or raster data)

```{r tmap-first-view, echo=FALSE}
#echo=FALSE to not show code in first version 

tmap_mode("plot") # to try to avoid learnr problems with 'view' mode

# tmap_mode("view") #to set to tmap interactive viewing mode

# getting error on deploying to shinyapps
#Error in value[3L] :OGRCreateCoordinateTransformation() returned NULL: PROJ available?
#potential solution
#https://stackoverflow.com/questions/61286108/error-in-cpl-transformx-crs-aoi-pipeline-reverse-ogrcreatecoordinatetrans
#If you save an sf-dataframe with a newer version of GDAL, and then try on a system with an older version of GDAL, the projection info cannot be read properly.
#The solution is to re-set the projection:
#st_crs(data) <- 4326

sf::st_crs(africapitals) <- 4326
sf::st_crs(afrihighway) <- 4326
sf::st_crs(africountries) <- 4326
sf::st_crs(africontinent) <- 4326 #not used yet but just in case

#not the raster layer
#st_crs(afripop2020) <- 4326

tmap::tm_shape(afripop2020) +
  tm_raster(palette = rev(viridisLite::magma(5)), breaks=c(0,2,20,200,2000,25000)) +
  tm_shape(africountries) +
  tm_borders("white", lwd = .5) +
  #tm_text("iso_a3", size = "AREA") +
  tm_shape(afrihighway) +
  tm_lines(col = "red") + 
  tm_shape(africapitals) +
  tm_symbols(col = "blue", alpha=0.4, scale = .6 )+
  tm_legend(show = FALSE)
```


Cities, highways and boundaries are examples of point, line and polygon data termed **vector data**. 

The gridded population density data are termed **raster data**.

In R there is often more than one package that does the same thing. Which one is 'best' for you may depend on preference and can change over time. This is true for R spatial operations.  

In R the `sf` package deals with vector data (points, lines and polygons), and the `raster` package deals with raster data.

There are other packages too but we don't need those for now.


## C. Loading packages and data

Packages in R contain extra methods and data to add to base R.

We will be loading a package (`afrilearndata`) containing example data for us to look at.

We will also use the packages `sf` and `raster`, which allow us to deal with vector and raster data.

Using an R package requires a 2 step process :

1. `install.packages`               needed only once to install a package
from the internet
1. `library([package_name])`        needed each time you start a new R session

A package may have been installed on your system already because it is a 'dependency' needed for another package.

In this case the packages `afrilearndata`, `sf` and `raster` should already have been installed when you installed this package.

To check that the packages have been installed, try running the `library` commands below. If they have been installed, nothing should happen. Not very interesting but a good check and a good reminder that this is what you will need to do each time you start a new R session.

```{r library_packages, exercise = TRUE, exercise.eval = FALSE, message = FALSE, warning = FALSE}

# for vector data handling
library(sf) 

# for raster data handling
library(raster) 

# example spatial data for Africa
library(afrilearndata)

# for mapping
library(tmap)

```

```{r set-crs-and-tmap-mode, echo=FALSE}
#echo=FALSE to not show code 

#TO TRY TO AVOID TWO ERRORS LATER, repeated from above so after library() commands

tmap_mode("plot") # to try to avoid learnr problems with 'view' mode

# getting error on deploying to shinyapps
#Error in value[3L] :OGRCreateCoordinateTransformation() returned NULL: PROJ available?
#potential solution
#https://stackoverflow.com/questions/61286108/error-in-cpl-transformx-crs-aoi-pipeline-reverse-ogrcreatecoordinatetrans
#If you save an sf-dataframe with a newer version of GDAL, and then try on a system with an older version of GDAL, the projection info cannot be read properly.
#The solution is to re-set the projection:
#st_crs(data) <- 4326

sf::st_crs(africapitals) <- 4326
sf::st_crs(afrihighway) <- 4326
sf::st_crs(africountries) <- 4326
sf::st_crs(africontinent) <- 4326 #not used yet but just in case

#2021-02-04 this fails on shinyapps
#Error in value[[3L]](cond) : invalid crs: +init=EPSG:4326
#raster::crs(afripop2020) <- CRS('+init=EPSG:4326')

```

If you happen to get messages indicating any of the packages are not installed, you can use `install.packages` to install them.


## D. Spatial data objects 

We are going to take a look at the spatial data objects used to create the map shown at the start of the tutorial.

We call them 'objects' because the data are already stored in R. This is also to make clear the difference from a 'file' that is stored elsewhere on your computer. A 'file' can be read into an R 'object' and we will come to that later.  

First we will look at capital cities which are stored in an object called `africapitals`.

Using the plot method should display a number of maps of the point locations of African capitals. 

```{r sf-points-plot, exercise=TRUE, exercise.lines = NULL}

plot(africapitals)
#plot(sf::st_geometry(africapitals))

```

This uses the plot function defined in the `sf` package. It creates a series of maps and in each one the points are coloured according to the values stored in one column. There is a function in `sf` called `st_geometry()` that allows you to get just the spatial parts without the attributes and you can see the result of that by removing the # in front of the 2nd line of code in the window above and pressing 'Run code'.  But we are getting ahead of ourselves; let us have a look at the structure of the object itself.

In R there are various functions that can help us explore what an object contains. We find these particularly useful; there is some overlap between them.

1. str()        structure of the object, displays both names and values
1. head()       displays the first few rows of data with the column names
1. names()      gives just column names
1. class()      gives the class of the object, that is broadly what sort of object it is  

Have a look at the outputs for `africapitals` (uncomment the later lines to see their outputs) :

```{r sf-points-str, exercise=TRUE, exercise.lines = NULL}

str(africapitals)
#head(africapitals)
#names(africapitals)
#class(africapitals)

```

These show us that `africapitals` is of class `sf` and `data.frame` and contains a series of columns including ones named : 'capitalname', 'countryname' and 'geometry'.

`data.frame`, often referred to as just dataframe, is the most common object type in R certainly for new users. Dataframes store data in rows and named columns like a spreadsheet. 

`sf` objects are a special type of dataframe with a column called 'geometry' that contains the spatial information, and one row per feature. In this case the features are points.

If you look at the output from the `str()` command above you should see that the first value in the geometry column has the coordinates 7.17 9.18. Because the capitals data are points, they just have a single coordinate pair representing the longitude and latitude of each capital.

The highway and countries objects are also of class `sf` and contain geometry columns. You can uncomment the lines below and run to see what is contained in the first cell of the geometry column for the other vector objects. 

```{r sf-points-lines-polygons, exercise=TRUE, exercise.lines = NULL}

#The `paste()` command converts the object to text to ensure it appears in the learnr window.

paste(africapitals$geometry[1])
#paste(afrihighway$geometry[1])
#paste(africountries$geometry[1])

```

You should have seen that the geometry columns for the other objects contain multiple coordinates representing lines and polygons.

## E. First maps with `tmap` 

There are a number of packages for making maps that extend what is available from `sf`.

Package `tmap` is a good place to start; it offers both static and interactive mapping.

We can start with static plots of the capitals (points).

In `tmap` `tm_shape([object_name])` defines the data to be used. Then `+` to add code that defines how the data are displayed, e.g. `tm_symbols()` for points. Extra arguments can be specified to modify the data display.

See the hint button for how to set colour with `tm_symbols(col = "blue")` and `col=[column_name]` to set the colour of each point according to the data value stored in a column.

```{r tmap-points1-setup}
# to avoid issues with interactive maps https://github.com/rstudio/learnr/issues/529
# IdSeed must be set to be unique in the Rmd, even for mode('plot') to allow user to change
tmap_mode("plot")
htmlwidgets::setWidgetIdSeed(1)
```

```{r tmap-points1, exercise = TRUE, exercise.eval = TRUE, message = FALSE, warning = FALSE}

tm_shape(africapitals) +
  tm_symbols()              #default grey points

```

```{r tmap-points1-hint}

tm_shape(africapitals) + tm_symbols(col = "blue") #set colour directly

tm_shape(africapitals) + 
  tm_symbols(col = "pop")  #set colour to a data column

```

The highway network (lines) can be plotted using the same `tm_shape([object_name])` to start, then adding `tm_lines()` to display the lines. The hints button below shows options for colouring lines.

```{r tmap-lines1-setup}
# to avoid issues with interactive maps https://github.com/rstudio/learnr/issues/529
# IdSeed must be set to be unique in the Rmd, even for mode('plot') to allow user to change
tmap_mode("plot")
htmlwidgets::setWidgetIdSeed(2)
```

```{r tmap-lines1, exercise = TRUE, exercise.eval = TRUE, message = FALSE, warning = FALSE}

tm_shape(afrihighway) +
    tm_lines()

```

```{r tmap-lines1-hint}

tm_shape(afrihighway) + tm_lines(col = "red")

tm_shape(afrihighway) + tm_lines(col = "Name") #use a column name from the object

#Note in this case using 'Name' to colour the highways doesn't work very well because there are too many unique names 

```

Countries (polygons) can similarly be mapped using `tm_shape` and `tm_polygons`. See the hint button for options for colouring countries.

```{r tmap-polygons-setup}
# to avoid issues with interactive maps https://github.com/rstudio/learnr/issues/529
# IdSeed must be set to be unique in the Rmd, even for mode('plot') to allow user to change
tmap_mode("plot")
htmlwidgets::setWidgetIdSeed(3)
```

```{r tmap-polygons1, exercise = TRUE, exercise.eval = TRUE, message = FALSE, warning = FALSE}

tm_shape(africountries) +
  tm_polygons()

```

```{r tmap-polygons1-hint}

tm_shape(africountries) + tm_polygons(col="pop_est")

tm_shape(africountries) + tm_polygons(col="income_grp")

tm_shape(africountries) + tm_polygons(col="income_grp", border.col = "white")

```

Gridded (raster) data can represent e.g. remotely sensed or modelled data.

It can be displayed with `tm_shape([object_name])` & `tm_raster`. Here we specify the `breaks` or cutoffs to the different colour bands. 

In this example, if you use the default breaks by not specifying any arguments with `tm_raster()` (see the hint) the map looks entirely one colour. This is because there are few very high density cells and a majority of cells with very low values. This is a common issue with population data. The default (equal-interval) classification doesn't work well; most of the map falls in the lowest category. If you look very closely you can see a few very high value cells e.g. in Lagos & Cairo. 

```{r tmap-raster1-setup}
# to avoid issues with interactive maps https://github.com/rstudio/learnr/issues/529
# IdSeed must be set to be unique in the Rmd, even for mode('plot') to allow user to change
tmap_mode("plot")
htmlwidgets::setWidgetIdSeed(4)
```

```{r tmap-raster1, exercise = TRUE, exercise.eval = TRUE, message = FALSE, warning = FALSE}

tm_shape(afripop2020) +
    tm_raster(breaks=c(0,2,20,200,2000,25000))


```

```{r tmap-raster1-hint, exercise.lines = 7}

tm_shape(afripop2020) + tm_raster()

#changing the colour palette
tm_shape(afripop2020) + tm_raster(palette = rev(viridisLite::magma(5)), breaks=c(0,2,20,200,2000,25000))

```



## F. Mapping multiple 'layers'

In the previous section we showed how to make maps of individual data objects. Those sections of code can be combined to create multiple 'layer' maps as shown in the example below.

`tmap` (and other map packages) use the `+` symbol to combine layers.

Experiment with commenting out & in lines in the code below by adding and removing # at the start of lines and pressing Run Code.

Try to make maps :
1. without the highway network
2. without the raster population layer & with country boundaries that are visible
3. with text labels for ISO country codes

```{r tmap-vector-raster-setup}
# to avoid issues with interactive maps https://github.com/rstudio/learnr/issues/529
# IdSeed must be set to be unique in the Rmd, even for mode('plot') to allow user to change
tmap_mode("plot")
htmlwidgets::setWidgetIdSeed(5)
```

```{r tmap-vector-raster, exercise = TRUE, exercise.eval = TRUE, message = FALSE, warning = FALSE, exercise.setup='set-crs-and-tmap-mode'}

tmap::tm_shape(afripop2020) +
    tm_raster(palette = rev(viridisLite::magma(5)), breaks=c(0,2,20,200,2000,25000)) +
tm_shape(africountries) +
    tm_borders("white", lwd = .5) +
    #tm_text("iso_a3", size = "AREA") +
tm_shape(afrihighway) +
    tm_lines(col = "red") + 
tm_shape(africapitals) +
    tm_symbols(col = "blue", alpha=0.4, scale = .6 ) +
tm_legend(show = FALSE)

```


## G. Interactive maps

The maps created so far have been static. There are also great options for creating interactive maps, which are useful for web pages or reports where readers can zoom, pan and enable/disable layers.

In `tmap` you can keep the identical code that we've looked at so far and just add a single line before : `tmap_mode('view')` to change to interactive 'view' mode. View mode will remain active for your R session and you can switch back to static `plot` mode using `tmap_mode('plot')`. 

This is the identical code from the previous section but shown in view mode.

```{r tmap-interactive-setup}
# to avoid issues with interactive maps https://github.com/rstudio/learnr/issues/529
# IdSeed must be set to be unique in the Rmd, even for mode('plot') to allow user to change
#tmap_mode("plot")
htmlwidgets::setWidgetIdSeed(6)
```

```{r tmap-interactive, exercise = TRUE, exercise.eval = TRUE, message = FALSE, warning = FALSE, exercise.setup='set-crs-and-tmap-mode'}

tmap_mode('view') 

tmap::tm_shape(afripop2020) +
  tm_raster(palette = rev(viridisLite::magma(5)), breaks=c(0,2,20,200,2000,25000)) +
  tm_shape(africountries) +
  tm_borders("white", lwd = .5) +
  #tm_text("iso_a3", size = "AREA") +
  tm_shape(afrihighway) +
  tm_lines(col = "red") + 
  tm_shape(africapitals) +
  tm_symbols(col = "blue", alpha=0.4, scale = .6 )+
  tm_legend(show = FALSE)

```


You may want to go back to the earlier plots and see how they are modified by adding `tmap_mode('view')` before the code.


## H. Read spatial data from files

So far we have been using data that already exists within R as an R object.

The same things can be done on data coming from a file.

Spatial data can be read into R using `sf::st_read()` for vector data (points, lines and polygons) and the `raster` & `rgdal` packages for gridded data.

We show examples below using files that are stored in the package. To use with your own data replace filename1 & 2. (Note that these specified file names can also be a URL for data provided on the web.)


```{r read-files, exercise = TRUE, exercise.eval = FALSE, message = FALSE, warning = FALSE}

library(sf)
filename1 <- system.file("extdata","africountries.shp", package="afrilearndata", mustWork=TRUE)
myobject1 <- sf::st_read(filename1)

library(raster)
library(rgdal) 
filename2 <- system.file("extdata","afripop2020.tif", package="afrilearndata", mustWork=TRUE)
myobject2 <- raster::raster(filename2)

```

## Summary

Good persistence for getting this far !
  
  We hope you've enjoyed this brief intro to mapping with R.

We've shown you :
  
  i. storing and handling spatial data with the package `sf` 
i. making static & interactive maps with package `tmap`
i. reading in data from files using `sf` and `raster`

This is a start; there are plenty of other options (e.g. maps can also be made with the packages `mapview` & `ggplot2`). We will cover other options in later tutorials. Have a look at the [afrilearnr-crash-course](https://andysouth.shinyapps.io/afrilearnr-crash-course/) for some potential next steps. We welcome feedback - different ways of [getting in touch are on our website](https://afrimapr.github.io/afrimapr.website/get-involved/).

There is a short quiz if you'd like to test your learning. 

## Quiz

```{r quiz}
quiz(
  
  question("What is the term for point, line and polygon data ?",
    answer("raster", message = "raster is gridded data, the other alternative is vector (point,line,polygon)"),
    answer("sf", message = "`sf` is the R package for handling vector (point,line,polygon) data"),
    answer("vector", correct = TRUE),
    answer("squiggles", message = "they may sometimes look like this, but `vector` is the more accepted technical term"),  
    allow_retry = TRUE
  ),  
  question("In an `sf` object, which column contains spatial information ?",
    answer("spatial"),
    answer("longitude", message = "coordinates can be stored in columns called anything but `sf` uses the geometry column e.g. for plotting"),
    answer("geometry", correct = TRUE),
    answer("name"),  
    allow_retry = TRUE
  ),
  question("How can I read a shapefile into R ?",
    answer("read.csv()", message = "this is for reading data from a text file"),
    answer("<-"),
    answer("myobject <- sf::st_read()", correct = TRUE),
    answer("tmap"),  
    allow_retry = TRUE
  ),  
  question("Which R packages can be used to make maps ?",
    answer("tmap", correct = TRUE),
    answer("raster", correct = TRUE),    
    answer("ggplot", correct = TRUE),
    answer("sf", correct = TRUE),
    answer("mapview", correct = TRUE),  
    allow_retry = TRUE,
    incorrect = "All of these packages can be used to make maps ! Sometimes which one you choose can be down to preference."
  )
)
```

```{r echo=FALSE}
# chunk below enables printing whole tutorial from browser e.g. to pdf
# DO NOT put any #comments in the chunk below, that stops it from working !! 
# from https://github.com/rstudio/learnr/issues/465
# saving csss in a separate file print.css didn't work locally or on shinyapps because browser couldn't find file 
```
```{css echo=FALSE}
@media print {
  .topicsContainer,
  .topicActions,
  .exerciseActions .skip {
    display: none;
  }
  .topics .tutorialTitle,
  .topics .section.level2,
  .topics .section.level3:not(.hide) {
    display: block;
  }
  .topics {
    width: 100%;
  }
  .tutorial-exercise, .tutorial-question {
    page-break-inside: avoid;
  }
  .section.level3.done h3 {
    padding-left: 0;
    background-image: none;
  }
  .topics .showSkip .exerciseActions::before {
    content: "Topic not yet completed...";
    font-style: italic;
  }
}  
  
```


* * *

<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a> then was adapted and learnr-ified by Sara Stoudt, and further adapted and biologified by Jenna Ekwealor.
